# 1200最小绝对差 - 力扣（LeetCode）

## 解题思路

> 最初版本
```js
/**
 * @param {number[]} arr
 * @return {number[][]}
 */
var minimumAbsDifference = function(arr) {
    let arr_sort = arr.sort((a, b) => a - b);
    // 记录最小差值Map
    let obj = {};
    for (let i = 0, j = 1; i < arr.length && j < arr.length; i++, j++) {
        const cha = Math.abs(arr_sort[j] - arr_sort[i]);
        if (Object.keys(obj).includes(cha + '')) {
            obj[cha].push([arr_sort[i], arr_sort[j]])
        }
        else {
            obj[cha] = [[arr_sort[j], arr_sort[i]]];
        }
    }
    let minKey = Infinity;
    let minValues = null;

    for (const key in obj) {
        const numKey = Number(key);
        if (numKey < minKey) {
            minKey = numKey;
            minValues = obj[key];
        }
    }
    return minValues;
};
```
![](F:\JavaScript-Charles\LeetCode\images\Snipaste_2026-01-27_00-03-13.png)

> 求最小绝对差值，太久没思考了，脑子锈锈的，导致第一版错误很离谱.本来是很简单的题，写成这样真要反思我的基础以及知识的积累运用

#### 错误1
sort函数改变原数组，返回排序后数组，属于就地排序。
##### 数组方法大全

| 方法         | 改变原数组          | 不改变原数组 |
| ------------ | ------------------- | ------------ |
| `push`       | 末尾加              | ❌            |
| `pop`        | 末尾删              | ❌            |
| `shift`      | 头部删              | ❌            |
| `unshift`    | 头部加              | ❌            |
| `splice`     | 万能增删改          | ❌            |
| `sort`       | 排序                | ❌            |
| `reverse`    | 反转                | ❌            |
| `fill`       | 填充                | ❌            |
| `copyWithin` | 内部复制            | ❌            |
| `map`        | 映射                | ✅            |
| `filter`     | 过滤                | ✅            |
| `slice`      | 截取                | ✅            |
| `concat`     | 拼接                | ✅            |
| `flat`       | 拍平                | ✅            |
| `flatMap`    | map + flat          | ✅            |
| `toSorted`   | 新排序（ES2023）    | ✅            |
| `toReversed` | 新反转（ES2023）    | ✅            |
| `toSpliced`  | 新 splice（ES2023） | ✅            |
#### 错误2
一次循环，直接`i+1 - i`即可得到前后差值，竟然还用了第二变量j，而且这里还多想了，第一步已经正序排列了，不可能出现`i+1 - i`为负数的情况，不用包一层`Math.abs()`取绝对值
#### 错误3
直接记录一个默认最小值`min`，用`i+1 - i`的差值去做对比，如果小于`min`,则`min`等于本次差值。也不用去关心之前的差值对应的`[i, i+1]`, 因为已经有更小的值了，之前的已经废弃，直接就可以得到最后答案，不用去记录对象，最后再通过对比对象key的最小值来返回对应的数组。

## 最优解

```js
**最优解**
> 引用：/**
 * @param {number[]} arr
 * @return {number[][]}
 */
var minimumAbsDifference = function(arr) {
    // 先排序
    arr.sort((a, b) => a - b);
    // 记录最小差值
    let arr_min = [], min = Infinity;
    // 这里arr.length - 1, 因为在倒数第二个的时候其实已经跟最后一个对比过了，所以不用再去执行最后一次循环
    for (let i = 0; i < arr.length - 1; i++) {
        // 直接用后一位-前一位，就是之前的差值
        const cha = arr[i + 1] - arr[i];
        // cha跟记录的min进行对比，如果cha更小，则min=cha，并将当次的减数被减数放到数组
        // 这里不能用push，如果第一次计算的cha=2 记录一次，第二次cha=1，如果用了push，则会在第一次的基础上push,统计会出现问题
        if (cha < min) {
           min = cha;
           // 有更小的差值存在，会重新定义arr_min。
           arr_min = [arr[i], arr[i + 1]];
        }
        // 如果cha == min 则直接push进去
        else if (cha == min) {
            arr_min.push([arr[i], arr[i + 1]]);
        }
    }
    return arr_min;
};
```
![](F:\JavaScript-Charles\LeetCode\images\Snipaste_2026-01-27_00-06-52.png)
>
>标题：1200. 最小绝对差 - 力扣（LeetCode）
>
>网址：[https://leetcode.cn/problems/minimum-absolute-difference/?envType=daily-question&envId=2026-01-26](https://leetcode.cn/problems/minimum-absolute-difference/?envType=daily-question&envId=2026-01-26)